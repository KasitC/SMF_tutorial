---
title: "Single-molecule analysis of the change in RNA Pol II binding frequency upon triptolide treatment"
author: "Kasit Chatsirisupachai"
date: "2024-06-21"
output:
  html_document: 
    df_print: paged
  pdf_document: 
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
In previous examples, we only analyse SMF data in the bulk level (i.e. average methylation). However, the actual advantage of SMF comes from the analysis at the 'single-molecule' level. With this type of analysis, we can assign a molecular state for each single DNA molecule in the sequencing data. Moreover, this will lead us to the 'frequency' of each molecular state across the population. 

In this example, we will re-analyse a subset of data from the first SMF paper from the Krebs lab (Krebs _et al._, _Mol. Cell_, 2017). This paper investigated the turnover of RNA polymerase II (Pol II) in _Drosophila_ promoters. To study the binding of Pol II, each DNA molecule was assigned into one of the five promoter states (nucleosome, unbound, PIC, PIC.polII, and polII), based on the biology of known promoter motifs.

## Data
The data is the targeted amplicon dual-enzyme SMF of selected _Drosophila_ promoters on S2 cell line, with or without triptolide (TRP) treatment, an inhibitor of transcription initiation. SMF library were sequenced in paired-end using Illumina platform. Once obtain the raw sequencing data, Fastq files were aligned to the _Drosophila_ dm6 genome using `QuasR` package. Since this is an amplicon data, we do not remove duplicate reads.


# Pol II analysis

## Load libraries

```{r}
library(QuasR)
library(SingleMoleculeFootprinting)
library(BSgenome.Dmelanogaster.UCSC.dm6)
library(tidyverse)
library(ggplot2)
library(here)
library(stringi)
```

## Create QuasR input file
Similar to the previous example, we will first create QuasR input file.
All BAM files for this example are in the folder `/data/dataset_3_S2_amplicon_TRP`

```{r}
Qinput <- "/g/krebs/chatsiri/SMF_tutorial/analysis/example_3/Qinput_S2_DMSOvsTRP_subset.txt"

```

## Load the GRanges object containing promoters of interest
```{r}
TSSs <- readRDS("/g/krebs/chatsiri/SMF_tutorial/data/dataset_3_S2_amplicon_TRP/TSS_GRanges.rds")
print(TSSs)
```


## Call context methylation
As an example, we will first work on only one promoter region for now.

```{r}
MySample <- suppressMessages(readr::read_delim(Qinput, delim = "\t")[[2]])

genome <- BSgenome.Dmelanogaster.UCSC.dm6

# make cluster
cluObj <- makeForkCluster(nnodes = 4)

# define region of interest by extending the TSS to cover 500 bp (250 upstream and 250 downstream)
# select only one TSS: NM_080188.3
TSS <- TSSs[TSSs$gene_id == "NM_080188.3",]
gr <- resize(TSS, 500, fix = "center")

print(gr)

# Call context methylation
Methylation <- CallContextMethylation(sampleSheet = Qinput, 
                                        sample = MySample, 
                                        genome = genome, 
                                        RegionOfInterest = gr, 
                                        coverage = 20, 
                                        ConvRate.thr = 0.2, 
                                        returnSM = TRUE)
```


Unlike in previous example (`02_PEPC_vs_NEB`), we now set the parameter returnSM to `TRUE`. This will make the function return methylation status for each DNA molecule, in addition to the bulk average methylation level. Let's take a look at the Methylation object.


The first object in Methylation contains the bulk average methylation level at each cytosine, similar to what we saw previously in the `02_PEPC_vs_NEB` example.
```{r}
print(Methylation[[1]])
```
Here, we can already plot the average SMF signal, to see if TRP treatment actually reduce paused Pol II footprint.
```{r}
PlotAvgSMF(MethGR = Methylation[[1]], 
           RegionOfInterest = gr) +
  geom_vline(xintercept = 12505788, linetype="dashed", color = "grey")
```

From the average plot, we can observe a reduction of Pol II footprint at the pausing site (~30-50 nucleotides downstream of the TSS). We next ask, can we go beyond the bulk analysis and assign a promoter state to each single-molecule of DNA?


## Single-molecule sorting and quantification of promoter state frequencies
We will assign each DNA molecule to a promoter state (unassigned, nucleosome, unbound, PIC, PIC.polII, and polII).
These promoter states can be dictated by a four-bin methylation pattern. 
The bins and their relative location to the TSS are:
1. upstream [-58:-43], 2. TATA-box [-36:-22], 3. paused Pol II [28:47], and 4. downstream [54:69]

We will define an average cytosine methylation status in each bin. Thus, a vector of 4 can be derived.
For example, if there is only a Pol II bound at the paused Pol II site, and the other bins are unoccupied, we will encode a patter `1101`. There are 16 patters in total ($2^4$.) 


First, let's look at the second object in the Methylation object from above. This represents a sparse matrix containing single-molecule methylation status for each DNA molecule. Rows are DNA molecules, while columns are positions of each cytosine. `1` means unmethylated cytosine (i.e. "protected") and `2` means methylated cytosine (i.e. accessible).

```{r}
# DMSO
print(head(Methylation[[2]]$DMSO_DE_S2))

# TRP
print(head(Methylation[[2]]$TRP_DE_S2))
```

Here, we have to define the bin positions to the promoter we are working with. We can use the function `MakeBins` to do the job. As some promoters are located on the minus strand, we have to take this into account. (Yet, our example promoter (NM_080188.3) is on the plus strand)
```{r}
BinsCoordinates <- MakeBins(RegionsOfInterest = TSS, BinType = "Promoter", StrandAware = TRUE)
print(BinsCoordinates)

strand <- unique(as.character(strand(BinsCoordinates)))
print(strand)
```


Next, we can sort each read into one of the 16 patters. We will use the `SortedReads` function for this purpose.
```{r}
SortedReads <- lapply(Methylation[[2]], SortReads, BinsCoordinates = BinsCoordinates, 
                      coverage = 20, strand = strand)

# How many reads in each pattern?
# DMSO
lapply(SortedReads$DMSO_DE_S2, length) %>% unlist() %>% print()

# TRP
lapply(SortedReads$TRP_DE_S2, length) %>% unlist() %>% print()

# create a dataframe of state frequencies
StateFrequency_tbl <- StateQuantification(SortedReads = SortedReads, states = NULL)
print(StateFrequency_tbl)
```

Now, it's time to assign promoter states to bin patterns. Here, we need a bit of prior biological knowledge.
```{r}
promoter_states <- list(unassigned = c("0101", "0110", "1010"),
                        nucleosome = c("0000", "0001", "0010", "0011", "0100", "1000", "1100"),
                        unbound = c("0111", "1110", "1111"),
                        PIC = c("1011"),
                        PIC.polII = c("1001"),
                        polII = c("1101"))

promoter_statesF <- as.factor(unlist(lapply(seq_along(promoter_states), function(i){
  rep(names(promoter_states[i]), length(promoter_states[[i]]))}))[order(unlist(promoter_states))])

promoter_statesF <- factor(promoter_statesF, levels = names(promoter_states))

```

Finally, we will quantify promoter state frequencies.
```{r}
# All 16 possible states
allPos <- expand.grid(c(0,1), c(0,1), c(0,1), c(0,1))
states <- names(table(apply(allPos, 1, function(x){(paste(as.character((x)), collapse = ""))})))
print(states)

# our two samples
samples <- unique(StateFrequency_tbl$Sample)

# working on each sample
stateM_list <- lapply(samples, function(sample){
  
  print(paste0("Creating state matrix for: ", sample))
    
  # subset df to select only a sample we are working with
  StateFrequency_sample <- StateFrequency_tbl[StateFrequency_tbl$Sample == sample,]
    
  # create a matrix to store state frequencies
  stateM <- matrix(nrow = length(TSS), ncol = length(states))
  rownames(stateM) <- names(TSS)
  colnames(stateM) <- states
  
  # add frequencies to the state matrix
  for(state in StateFrequency_sample$State){
    stateM[, state] <- StateFrequency_sample[StateFrequency_sample$State == state, ]$Freqs
  }
  
  stateM[is.na(stateM)] <- 0
  
  return(stateM)
})

# Collapse state matrix to promoter states
collapse_states <- function(state_matrix, promoter_statesF){
  return(t(apply(state_matrix, 1, function(x){tapply(x, promoter_statesF, sum)})))
}

grouped_freq_mats <- lapply(stateM_list, collapse_states, promoter_statesF = promoter_statesF)
print(grouped_freq_mats)
```

You can see that Pol II binding frequency decreased upon TRP treatment.


We can plot SMF signal again, this time with a single-molecule stack and a quantification bar.
```{r}
# add column TF in the BinsCoordinates object (due to the argument in the plotting function)
BinsCoordinates$TF <- BinsCoordinates$name

# Plotting function (you can try to unpack this function!)
SingleMoleculeFootprinting::PlotSingleSiteSMF(Methylation = Methylation,
                                              RegionOfInterest = resize(TSS, width = 400, fix = "center"),
                                              TFBSs = BinsCoordinates, 
                                              sorting.strategy = "promoter",
                                              SortedReads = SortedReads)
```


## Can we work on multiple promoters simultaneously?
Let's go back to the `CallContextMethylation` step. Instead of working on one promoter, we can write a function to work on multiple promoters in parallel.
```{r}
# Create a methylation calling windows across all 36 promoters
gr <- resize(TSSs, 500, fix = "center")
print(gr)

# Call context methylation and sorting in parallel
# note that the code below was modified from the wrapper function `SortReadsByPromoter_MultiSiteWrapper` for the purpose of this training. The actual function `SortReadsByPromoter_MultiSiteWrapper` is very useful for the genome-wide analysis, please feel free to have a look.

# this would take some time to run.
SortedReads <- parallel::mclapply(seq_along(gr), function(i) {
  CurrentWindow <- gr[i]
  print(paste0("Working on: promoter ", i))
  ExperimentType <- suppressMessages(SingleMoleculeFootprinting::DetectExperimentType(Samples = MySample))
  Methylation <- CallContextMethylation(sampleSheet = Qinput,
                                        sample = MySample,
                                        genome = genome,
                                        RegionOfInterest = CurrentWindow,
                                        coverage = 20, 
                                        ConvRate.thr = 0.2,
                                        returnSM = TRUE)
  SortedReads_window <- list(SortReadsBySinglePromoter(MethSM = Methylation[[2]],
                                                       TSS = TSSs[i], 
                                                       coverage = 20))
  names(SortedReads_window) <- names(TSSs[i])
  
  return(SortedReads_window)
  }, mc.cores = 8)

SortedReads <- unlist(SortedReads, recursive = FALSE)

# Calculate state frequencies
StateFrequency_tbl <- Reduce(rbind, parallel::mclapply(seq_along(SortedReads), 
        function(i) {
            StateQuantification_tbl = StateQuantification(SortedReads = SortedReads[[i]], 
                states = NULL)
            StateQuantification_tbl$TSS = names(SortedReads[i])
            StateQuantification_tbl
        }, mc.cores = 4))

StateFrequency_tbl <- drop_na(StateFrequency_tbl)
```

Again, the next step is to assign 4-bin states into promoter states. As previously we only work on one promoter, can we modify the codes to work on all promoters?
```{r}
# All 16 possible states
allPos <- expand.grid(c(0,1), c(0,1), c(0,1), c(0,1))
states <- names(table(apply(allPos, 1, function(x){(paste(as.character((x)), collapse = ""))})))
print(states)

# our two samples
samples <- unique(StateFrequency_tbl$Sample)

###################################
# select only promoters that are present in both samples
prom_DMSO <- StateFrequency_tbl %>% filter(Sample == "DMSO_DE_S2") %>% select(TSS) %>% unique() %>% unlist()

prom_TRP <- StateFrequency_tbl %>% filter(Sample == "TRP_DE_S2") %>% select(TSS) %>% unique() %>% unlist()

shared_prom <- prom_TRP[prom_TRP %in% prom_DMSO]

# filter to keep promoters that are in both samples
StateFrequency_tbl <- StateFrequency_tbl %>% filter(TSS %in% shared_prom)
###################################

# working on each sample
stateM_list <- lapply(samples, function(sample){
  
  print(paste0("Creating state matrix for: ", sample))
    
  # subset df to select only a sample we are working with
  StateFrequency_sample <- StateFrequency_tbl %>% filter(Sample == sample)
    
  # create a matrix to store state frequencies
  stateM <- matrix(nrow = length(unique(StateFrequency_tbl$TSS)), ncol = length(states))
  rownames(stateM) <- unique(StateFrequency_tbl$TSS)
  colnames(stateM) <- states
  
  # add frequencies to the state matrix
  for(promoter in unique(StateFrequency_tbl$TSS)){
    tmp <- StateFrequency_sample[StateFrequency_sample$TSS == promoter,]
    for(state in unique(tmp$State)){
    stateM[promoter, state] <- tmp[tmp$State == state, ]$Freqs
    }
  }
  
  stateM[is.na(stateM)] <- 0
  
  return(stateM)
})

# Collapse state matrix to promoter states
collapse_states <- function(state_matrix, promoter_statesF){
  return(t(apply(state_matrix, 1, function(x){tapply(x, promoter_statesF, sum)})))
}

grouped_freq_mats <- lapply(stateM_list, collapse_states, promoter_statesF = promoter_statesF)

names(grouped_freq_mats) <- c("DMSO", "TRP")
```


Finally, it's always a good idea to plot. So, we will make a boxplot showing a decrease of Pol II binding frequency upon TRP treatment.
```{r}
DMSO <- as.data.frame(grouped_freq_mats$DMSO)
DMSO$polII_all <- DMSO$PIC.polII + DMSO$polII

TRP <- as.data.frame(grouped_freq_mats$TRP)
TRP$polII_all <- TRP$PIC.polII + TRP$polII

plot_df <- data.frame(DMSO = DMSO$polII_all, TRP = TRP$polII_all)
plot_df <- reshape2::melt(plot_df)

ggplot(plot_df, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  xlab("Treatment") + ylab("Pol II binding frequency (%)") +
  theme_bw()
```


## Bonus: Genome-wide quantification of promoter states
Of course, we can use SMF to quantify promoter states across the genome. Here, I reanalysed genome-wide data from S2 _Drosophila_ cells (Krebs _et al._, _Mol. Cell_, 2017). I stored promoter state frequency in an rds object. 
I further analysed Pol II ChIP-seq, PRO-seq, DNase-seq, and MNase-seq from publicly available data sets.
In the below chunk of code, we will correlate different data types with promoter state frequencies obtained from SMF.
```{r}
# Load different data sets
SMF_state_freq <- readRDS("/g/krebs/chatsiri/SMF_tutorial/data/dataset_3_S2_amplicon_TRP/DM_S2_DE_promoter_states_freq_matrix_avg_downstream_bins.rds")
ChIP_seq <- readRDS("/g/krebs/chatsiri/SMF_tutorial/data/dataset_3_S2_amplicon_TRP/S2_PolII_ChIP_seq.rds")
PRO_seq <- readRDS("/g/krebs/chatsiri/SMF_tutorial/data/dataset_3_S2_amplicon_TRP/S2_PRO_seq.rds")
MNase_seq <- readRDS("/g/krebs/chatsiri/SMF_tutorial/data/dataset_3_S2_amplicon_TRP/S2_MNase.rds")
DHS_seq <- readRDS("/g/krebs/chatsiri/SMF_tutorial/data/dataset_3_S2_amplicon_TRP/S2_DHS.rds")


### Join data frames
SMF_state_freq$row.names <- row.names(SMF_state_freq)
ChIP_seq$row.names <- row.names(ChIP_seq)
MNase_seq$row.names <- row.names(MNase_seq)
PRO_seq$row.names <- row.names(PRO_seq)
DHS_seq$row.names <- row.names(DHS_seq)

# put all data frames into list
df_list <- list(SMF_state_freq, 
                ChIP_seq, 
                MNase_seq,
                PRO_seq,
                DHS_seq)
# merge all data frames in the list
df_list %>% reduce(full_join, 
                   by = "row.names") -> merged_df

merged_df$row.names <- NULL

merged_df %>% drop_na() -> merged_df

plot_df <- cor(merged_df)
### Heatmap
pheatmap::pheatmap(plot_df)
```
